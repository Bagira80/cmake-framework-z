##
# @file
# @brief The "root" import-file that will be loaded by a call to `find_package(@PackageName@)`.
# @note This (CMake-)script is auto-generated. Do not edit it directly!
# 
# This CMake-script provides support for loading/importing the @PackageName@ CMake package by a
# call to CMake's `find_package` command. It describes how "bundled" components of package
# @PackageName@ will be loaded.
#
# The typical use would be to call `find_package` like this:
#
# ```
# find_package(@PackageName@ 1.0
#     REQUIRED COMPONENTS platform::core network::core
#     OPTIONAL_COMPONENTS network::HTML
# )
# ```
#
# The above invocation would search for package `@PackageName@` with version `1.0` and its three
# components `@PackageName@::platform::core`, `@PackageName@::network::core` and
# `@PackageName@::network::HTML`. On success, at least the required components are guaranteed to
# have been found, while the optional component `@PackageName@::network::HTML` might have been
# found or not. You could test for the existence of variable `@PackageName@_network__HTML_FOUND`
# in order to determine if the optional component had been found.
#
# Note that a component's name is case-sensitive. It might just consist of a simple name or, as in
# the example above, of multiple "sub-components", in general separated by `::`. (The `*_FOUND`
# variables' names always habe `:` replaced by `_`.)
#
# It is good practice for a `find_package` import-script to create imported targets whose names
# correspond to the components' names, but all lowercase except for the top-most part which equals
# the package name, e.g. a target `@PackageName@::platform::core` for the component with the same
# name and `@PackageName@::network::html` for the component `@PackageName@::network::HTML.  
# However, if a component had been found other (differently named) targets might have been created
# instead (or as well).
#
# Requesting no component, when calling `find_package` as shown in the following example, will
# make all bundled (and therefore installed) components available:
#
# ```
# find_package(@PackageName@ 1.0 REQUIRED)
# ```
#
# In this case a variable `@PackageName@_ALL_BUNDLED_COMPONENTS` will be set and will contain the
# names of all found components.
#
# By default, the imported targets have local scope. However, if the boolean variable
# `@PackageName@_IMPORT_GLOBALLY` is set to `TRUE` then these imported targets will be promoted to
# global scope and will be available everywhere.  
# In case this package-config is found as an alias (or substitute) for a differently named package
# `Foo` (by using `find_package`s `NAMES` option) the variable `Foo_IMPORT_GLOBALLY` is considered
# instead for determining if the imported targets shall be promoted to global scope.
#
# The following variables control the verbosity of the output generated by `find_package`:
# * `@PackageName@_VERBOSE`: Enable verbose output.
# * `@PackageName@_DEBUG`: Enable (even more verbose) debug output.
#
# In case this package-config is found as an alias (or substitute) for a differently named package
# `Foo` (by using `find_package`s `NAMES` option) the following alternative variables have the
# same effect on controlling the verbosity of the output generated by `find_package`:
# * `Foo_VERBOSE`: Enable verbose output.
# * `Foo_DEBUG`: Enable (even more verbose) debug output.
#


# Alternative package-name used internally.
string( TOLOWER "__@PackageName@" __package_name )


# Print verbose/debug messages.
if (@PackageName@_VERBOSE OR @PackageName@_DEBUG OR ${CMAKE_FIND_PACKAGE_NAME}_VERBOSE OR ${CMAKE_FIND_PACKAGE_NAME}_DEBUG )
    # Is this package found as an alias for a differently named package?
    # Note: This can occur, if calling find_package with the `NAMES` option like this:
    #       find_package(<some_package> ... NAMES @PackageName@ ...)
    if (NOT CMAKE_FIND_PACKAGE_NAME STREQUAL "@PackageName@")
        message( STATUS "Found ${CMAKE_FIND_PACKAGE_NAME} (with alias name \"@PackageName@\") ${${CMAKE_FIND_PACKAGE_NAME}_VERSION} at ${${CMAKE_FIND_PACKAGE_NAME}_DIR}" )
    else()
        message( STATUS "Found @PackageName@ ${@PackageName@_VERSION} at ${@PackageName@_DIR}" )
    endif()

    # Determine list of required and optional components that were requrested.
    foreach( ${__package_name}_comp IN LISTS ${CMAKE_FIND_PACKAGE_NAME}_FIND_COMPONENTS )
        if (${${CMAKE_FIND_PACKAGE_NAME}_FIND_REQUIRED_${${__package_name}_comp}})
            set( ${__package_name}_COMPONENTS "${${__package_name}_COMPONENTS} ${${__package_name}_comp}" )
        else()
            set( ${__package_name}_OPTIONAL_COMPONENTS "${${__package_name}_OPTIONAL_COMPONENTS} ${${__package_name}_comp}" )
        endif()
    endforeach()

    # Determine the requested configuration (e.g. `REQUIRED COMPONENTS network::core`)
    set( ${__package_name}_CONFIG )
    if (${CMAKE_FIND_PACKAGE_NAME}_FIND_QUIETLY)
        set( ${__package_name}_CONFIG "${${__package_name}_CONFIG} QUIET" )
    endif()
    if (${CMAKE_FIND_PACKAGE_NAME}_FIND_REQUIRED)
        set( ${__package_name}_CONFIG "${${__package_name}_CONFIG} REQUIRED" )
    endif()
    if (${__package_name}_COMPONENTS)
        set( ${__package_name}_CONFIG "${${__package_name}_CONFIG} COMPONENTS${${__package_name}_COMPONENTS}" )
    endif()
    if (${__package_name}_OPTIONAL_COMPONENTS)
        set( ${__package_name}_CONFIG "${${__package_name}_CONFIG} OPTIONAL_COMPONENTS${${__package_name}_OPTIONAL_COMPONENTS}" )
    endif()

    # Output requested configuration (e.g. `REQUIRED COMPONENTS network::core`)
    if (${__package_name}_CONFIG)
        message( STATUS "  Requested configuration: ${${__package_name}_CONFIG}" )
    endif()

    # Cleanup.
    unset( ${__package_name}_CONFIG )
    unset( ${__package_name}_COMPONENTS )
    unset( ${__package_name}_OPTIONAL_COMPONENTS )
endif()


##
# @name __@PackageName@_strip_package_name( result_name name separator )
# @brief Strips the package-name ("@PackageName@") from the given `name` (ignoring the case) and returns the resulting name.
# @param result_name The variable (in the caller's scope) which will be set to the resulting name.
# @param name The full name (of a bundled component) from which the package-name shall be split
#        (ignoring the case).
# @param separator The separator string by which individual parts of the full name (of a bundled
#        component) are separated.
#
function( __@PackageName@_strip_package_name result_name name separator )
    # Find index at which the first part of the full name is
    # separated from the remaining part by the given separator.
    string( FIND "${name}" "${separator}" index )
    # Compare first part of the full name with "@PackageName@" (ignoring case).
    string( SUBSTRING "${name}" 0 ${index} first_part )
    string( TOLOWER "${first_part}" first_part )
    string( TOLOWER "@PackageName@" package_name )
    if (first_part STREQUAL package_name AND NOT index EQUAL -1)
        # Extract remaining part of the full name.
        string( LENGTH "${separator}" length )
        math( EXPR index "${index} + ${length}" )
        string( SUBSTRING "${name}" ${index} -1 remaining_part )
        # The remaining part of the full name is what needs to be returned as resulting name.
        set( ${result_name} "${remaining_part}" PARENT_SCOPE )
    else()
        # The full name is what needs to be returned as resulting name.
        set( ${result_name} "${name}" PARENT_SCOPE )
    endif()
endfunction()


##
# @name __@PackageName@_read_bundled_component_info( filepath name name_separator search_name version export_name )
# @brief Returns information about a bundled component of package `@PackageName@` from the given `filepath`.
# @param filepath The path to the file containing information about the bundled component in question.
# @param name The variable via which the name of the bundled component will be returned.
# @param name_separator The variable via which the name-separator of the bundled component will be
#        returned.
# @param search_name The variable via which the name of the bundled component will be returned
#        under which it shall be searched.
# @param version The variable via which the version of the bundled component will be returned.
# @param export_name The variable via which the export-name of the bundled component will be
#        returned.
#
function( __@PackageName@_read_bundled_component_info filepath name name_separator search_name version export_name )
    # Read in name, export-name and version of current component.
    include( "${filepath}" )
    # Store values in return-variable.
    set( ${name}           "${BUNDLED_COMPONENT_NAME}"           PARENT_SCOPE )
    set( ${name_separator} "${BUNDLED_COMPONENT_NAME_SEPARATOR}" PARENT_SCOPE )
    set( ${search_name}    "${BUNDLED_COMPONENT_SEARCH_NAME}"    PARENT_SCOPE )
    set( ${version}        "${BUNDLED_COMPONENT_VERSION}"        PARENT_SCOPE )
    set( ${export_name}    "${BUNDLED_COMPONENT_EXPORTNAME}"     PARENT_SCOPE )
endfunction()


##
# @name __@PackageName@_read_all_bundled_components_info( names name_separators search_names versions export_names )
# @brief Returns information about all bundled components of package `@PackageName@`.
# @param names The variable via which the names of the bundled components will be returned.
# @param name_separators The variable via which the name-separators of the bundled components will
#        be returned.
# @param search_names The variable via which the names of the bundled component will be returned
#        under which they shall be searched.
# @param versions The variable via which the versions of the bundled components will be returned.
# @param export_names The variable via which the export-names of the bundled components will be
#        returned.
#
function( __@PackageName@_read_all_bundled_components_info names name_separators search_names versions export_names )
    # Search for all files with information about bundled components.
    file( GLOB filepaths
        LIST_DIRECTORIES false
        "${CMAKE_CURRENT_LIST_DIR}/components/*.BundledComponent.cmake"
    )
    # Extract and collect information from files.
    set( comp_names )
    set( comp_name_separators )
    set( comp_search_names )
    set( comp_versions )
    set( comp_export_names )
    foreach( filepath IN LISTS filepaths )
        __@PackageName@_read_bundled_component_info( ${filepath} name name_separator search_name version export_name )
        list( APPEND comp_names           "${name}" )
        list( APPEND comp_name_separators "${name_separator}" )
        list( APPEND comp_search_names    "${search_name}" )
        list( APPEND comp_versions        "${version}" )
        list( APPEND comp_export_names    "${export_name}" )
    endforeach()
    # Return collected information.
    set( ${names}           "${comp_names}"           PARENT_SCOPE )
    set( ${name_separators} "${comp_name_separators}" PARENT_SCOPE )
    set( ${search_names}    "${comp_search_names}"    PARENT_SCOPE )
    set( ${versions}        "${comp_versions}"        PARENT_SCOPE )
    set( ${export_names}    "${comp_export_names}"    PARENT_SCOPE )
endfunction()


##
# @name __@PackageName@_find_bundled_component( component version required quiet )
# @brief Tries to find the single given component of package `@PackageName@`.
# @param component The (fully qualified) component which is searched.
# @param version The version of the component that will be searched.
# @param required Determines if finding the component is required.
# @param quiet Determines if finding the component shall be done quietly.
#
macro( __@PackageName@_find_bundled_component component version required quiet )
    # Shall finding the component be done quietly?
    set( ${__package_name}_QUIET )
    if (${CMAKE_FIND_PACKAGE_NAME}_FIND_QUIETLY OR ${quiet})
        set( ${__package_name}_QUIET QUIET )
    endif()

    # Is finding the component required (and should we fail immediately)?
    set( ${__package_name}_REQUIRED )
    if (${required} AND ${CMAKE_FIND_PACKAGE_NAME}_FIND_REQUIRED)
        set( ${__package_name}_REQUIRED REQUIRED )
    endif()

    # A hint, where to look for the import-script of the component.
    get_filename_component( ${__package_name}_CMAKEDIR "${CMAKE_CURRENT_LIST_DIR}/.." ABSOLUTE )

    # Now, search for the component.
    if (@PackageName@_DEBUG OR ${CMAKE_FIND_PACKAGE_NAME}_DEBUG)
        message( STATUS "@PackageName@Config: find_package(${component} ${version} EXACT CONFIG ${${__package_name}_REQUIRED} ${${__package_name}_QUIET} HINTS ${${__package_name}_CMAKEDIR})" )
    endif()
    find_package( ${component} ${version} EXACT CONFIG ${${__package_name}_REQUIRED} ${${__package_name}_QUIET} HINTS ${${__package_name}_CMAKEDIR} )

    # Cleanup.
    unset( ${__package_name}_QUIET )
    unset( ${__package_name}_REQUIRED )
    unset( ${__package_name}_CMAKEDIR )
endmacro()


##
# @name __@PackageName@_find_requested_component( component required quiet )
# @brief Tries to find the single given component of package `@PackageName@`.
# @param component The component which is searched. (It can only be found if it was bundled!)
# @param required Determines if finding the component is required.
# @param quiet Determines if finding the component shall be done quietly.
#
macro( __@PackageName@_find_requested_component component required quiet )
    # Variable `component` might consist of several sub-components, separated by `::`. Therefore,
    # replace each colon by an underscore and make everything lowercase, in order to search for the
    # bundled component information file!
    string( REPLACE ":" "_" ${__package_name}_component "${component}" )
    string( TOLOWER "${${__package_name}_component}" lowercase_${__package_name}_component )

    # Not a bundled component?
    if (NOT EXISTS "${CMAKE_CURRENT_LIST_DIR}/components/${lowercase_${__package_name}_component}.BundledComponent.cmake")
        if (${required})
            if (${CMAKE_FIND_PACKAGE_NAME}_FIND_REQUIRED)
                message( FATAL_ERROR "@PackageName@Config: No bundled component '${component}'." )
            else()
                message( SEND_ERROR "@PackageName@Config: No bundled component '${component}'." )
            endif()
        elseif (@PackageName@_DEBUG OR ${CMAKE_FIND_PACKAGE_NAME}_DEBUG OR NOT ${quiet})
            message( STATUS "@PackageName@Config: No bundled component '${component}'. Ignored, because requested as optional component." )
        endif()
    else()
        # Read information about bundled component.
        __@PackageName@_read_bundled_component_info(
            "${CMAKE_CURRENT_LIST_DIR}/components/${lowercase_${__package_name}_component}.BundledComponent.cmake"
            ${__package_name}_comp_fullname
            ${__package_name}_comp_name_separator
            ${__package_name}_comp_search_name
            ${__package_name}_comp_version
            ${__package_name}_comp_export_name
        )
        # Verify that the bundled component is really what was requested.
        __@PackageName@_strip_package_name( ${__package_name}_comp_name
            ${${__package_name}_comp_fullname}
            ${${__package_name}_comp_name_separator}
        )
        if (NOT ${__package_name}_comp_name STREQUAL ${component})
            if (${required})
                if (${CMAKE_FIND_PACKAGE_NAME}_FIND_REQUIRED)
                    message( FATAL_ERROR "@PackageName@Config: No bundled component '${component}'. (Did you mean '${${__package_name}_comp_name}'?)" )
                else()
                    message( SEND_ERROR "@PackageName@Config: No bundled component '${component}'. (Did you mean '${${__package_name}_comp_name}'?)" )
                endif()
            elseif (@PackageName@_DEBUG OR ${CMAKE_FIND_PACKAGE_NAME}_DEBUG OR NOT ${quiet})
                message( STATUS "@PackageName@Config: No bundled component '${component}'. (Did you mean '${${__package_name}_comp_name}'?) Ignored, because requested as optional component." )
            endif()
        else()
            # Search for the bundled component.
            __@PackageName@_find_bundled_component( ${${__package_name}_comp_search_name} ${${__package_name}_comp_version} ${required} ${quiet} )

            # Found at all?
            if (NOT ${${__package_name}_comp_search_name}_FOUND)
                if (${required})
                    message( SEND_ERROR "@PackageName@Config: Unable to find component '${component}'." )
                elseif (@PackageName@_DEBUG OR ${CMAKE_FIND_PACKAGE_NAME}_DEBUG)
                    message( STATUS "@PackageName@Config: Unable to find (optional) component '${component}'." )
                endif()
            endif()
        endif()
    endif()

    # Set alternative `*_FOUND` variables.
    if (DEFINED "${__package_name}_comp_search_name" AND DEFINED "${${__package_name}_comp_search_name}_FOUND")
        set( ${CMAKE_FIND_PACKAGE_NAME}_${${__package_name}_component}_FOUND ${${${__package_name}_comp_search_name}_FOUND} )
        set( @PackageName@_${${__package_name}_component}_FOUND              ${${${__package_name}_comp_search_name}_FOUND} )
    else()
        set( ${CMAKE_FIND_PACKAGE_NAME}_${${__package_name}_component}_FOUND 0 )
        set( @PackageName@_${${__package_name}_component}_FOUND              0 )
    endif()

    # Cleanup.
    unset( ${__package_name}_component )
    unset( lowercase_${__package_name}_component )
    unset( ${__package_name}_comp_fullname )
    unset( ${__package_name}_comp_name )
    unset( ${__package_name}_comp_name_separator )
    unset( ${__package_name}_comp_search_name )
    unset( ${__package_name}_comp_version )
    unset( ${__package_name}_export_name )
endmacro()


##
# @name __@PackageName@_find_all_bundled_components()
# @brief Tries to find all bundled components of package `@PackageName@`.
#
macro( __@PackageName@_find_all_bundled_components )
    # Read information about bundled components.
    set( ${__package_name}_components_names )
    set( ${__package_name}_components_name_separators )
    set( ${__package_name}_components_search_names )
    set( ${__package_name}_components_versions )
    set( ${__package_name}_components_export_names )
    __@PackageName@_read_all_bundled_components_info(
        ${__package_name}_components_names
        ${__package_name}_components_name_separators
        ${__package_name}_components_search_names
        ${__package_name}_components_versions
        ${__package_name}_components_export_names
    )

    # Output information about all bundled components?
    if (@PackageName@_DEBUG OR ${CMAKE_FIND_PACKAGE_NAME}_DEBUG)
        set( ${__package_name}_components_with_versions )
        foreach( ${__package_name}_comp_fullname ${__package_name}_comp_name_separator ${__package_name}_comp_version
                 IN ZIP_LISTS ${__package_name}_components_names ${__package_name}_components_name_separators ${__package_name}_components_versions )
            # Strip package-name from component full-name.
            __@PackageName@_strip_package_name( ${__package_name}_comp_name
                ${${__package_name}_comp_fullname}
                ${${__package_name}_comp_name_separator}
            )
            set( ${__package_name}_components_with_versions "${${__package_name}_components_with_versions} ${${__package_name}_comp_name}=${${__package_name}_comp_version}" )
        endforeach()
        message( STATUS "@PackageName@Config: Bundled components: ${${__package_name}_components_with_versions}" )
        unset( ${__package_name}_components_with_versions )  # Cleanup.
    endif()

    # Search for all bundled components.
    set( ${CMAKE_FIND_PACKAGE_NAME}_ALL_BUNDLED_COMPONENTS )
    foreach( ${__package_name}_comp_fullname ${__package_name}_comp_name_separator ${__package_name}_comp_search_name ${__package_name}_comp_version
             IN ZIP_LISTS ${__package_name}_components_names ${__package_name}_components_name_separators ${__package_name}_components_search_names ${__package_name}_components_versions )
        # Strip package-name from component full-name.
        __@PackageName@_strip_package_name( ${__package_name}_comp_name
            ${${__package_name}_comp_fullname}
            ${${__package_name}_comp_name_separator}
        )

        # Search for the bundled component.
        __@PackageName@_find_bundled_component( ${${__package_name}_comp_search_name} ${${__package_name}_comp_version} 1 1 )  # REQUIRED and QUIET!

        # Set alternative `*_FOUND` variables.
        if (DEFINED "${${__package_name}_comp_search_name}_FOUND")
            set( ${CMAKE_FIND_PACKAGE_NAME}_${${__package_name}_comp_name}_FOUND ${${${__package_name}_comp_search_name}_FOUND} )
            set( @PackageName@_${${__package_name}_comp_name}_FOUND              ${${${__package_name}_comp_search_name}_FOUND} )
        else()
            set( ${CMAKE_FIND_PACKAGE_NAME}_${${__package_name}_comp_name}_FOUND 0 )
            set( @PackageName@_${${__package_name}_comp_name}_FOUND              0 )
        endif()

        # Append to list of all bundled components (if found at all).
        if (${${__package_name}_comp_search_name}_FOUND)
            list( APPEND ${CMAKE_FIND_PACKAGE_NAME}_ALL_BUNDLED_COMPONENTS ${${__package_name}_comp_fullname} )
        elseif (${CMAKE_FIND_PACKAGE_NAME}_FIND_REQUIRED)
            message( FATAL_ERROR "@PackageName@Config: Unable to find bundled component '${${__package_name}_comp_name}'." )
        else()
            message( SEND_ERROR "@PackageName@Config: Unable to find bundled component '${${__package_name}_comp_name}'." )
        endif()
    endforeach()

    # Output information about all bundled components that were found?
    if (@PackageName@_DEBUG OR ${CMAKE_FIND_PACKAGE_NAME}_DEBUG)
        list( JOIN ${CMAKE_FIND_PACKAGE_NAME}_ALL_BUNDLED_COMPONENTS " " ${__package_name}_all_bundled_components )
        message( STATUS "@PackageName@Config: ${CMAKE_FIND_PACKAGE_NAME}_ALL_BUNDLED_COMPONENTS: ${${__package_name}_all_bundled_components}" )
        unset( ${__package_name}_all_bundled_components )  # Cleanup.
    endif()

    # Cleanup.
    unset( ${__package_name}_components_names )
    unset( ${__package_name}_components_search_names )
    unset( ${__package_name}_components_versions )
    unset( ${__package_name}_components_export_names )
    unset( ${__package_name}_components_lowercase_names )
    unset( ${__package_name}_comp_name )
endmacro()


# Find components.
if (NOT ${CMAKE_FIND_PACKAGE_NAME}_FIND_COMPONENTS)
    # Find all bundled components.
    set( ${CMAKE_FIND_PACKAGE_NAME}_ALL_BUNDLED_COMPONENTS )
    __@PackageName@_find_all_bundled_components()
else()
    # Find all requested components.
    foreach( ${__package_name}_comp IN LISTS ${CMAKE_FIND_PACKAGE_NAME}_FIND_COMPONENTS )
        __@PackageName@_find_requested_component( ${${__package_name}_comp} ${${CMAKE_FIND_PACKAGE_NAME}_FIND_REQUIRED_${${__package_name}_comp}} 0 )
    endforeach()
endif()

# Remove alternative package-names again.
unset( __package_name )
